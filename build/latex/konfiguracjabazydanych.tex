%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,polish]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}


\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Sonny]{fncychap}
\ChNameVar{\Large\normalfont\sffamily}
\ChTitleVar{\Large\normalfont\sffamily}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionspolish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{Konfiguracja bazy danych}
\date{02 lip 2024}
\release{}
\author{Hubert Albanowsski, Filip Opac}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxstepscope


\chapter{Konfiguracja bazy danych}
\label{\detokenize{Konfiguracja-bazy-danych:konfiguracja-bazy-danych}}\label{\detokenize{Konfiguracja-bazy-danych::doc}}

\section{Lokalizacja i struktura katalogów}
\label{\detokenize{Konfiguracja-bazy-danych:lokalizacja-i-struktura-katalogow}}

\subsection{Lokalizacja:}
\label{\detokenize{Konfiguracja-bazy-danych:lokalizacja}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} \begin{description}
\sphinxlineitem{Katalog danych:}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{/var/lib/postgresql/\textless{}wersja\textgreater{}/main}} na na systemach Debian/Ubuntu

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{/var/lib/pgsql/\textless{}wersja\textgreater{}/data}} na systemach Red Hat/CentOS.

\item {} 
\sphinxAtStartPar
Zawiera wszystkie dane, pliki konfiguracyjne, logi i pliki kontrolne.

\end{itemize}

\end{description}

\item {} \begin{description}
\sphinxlineitem{Katalog Konfiguracyjny:}\begin{itemize}
\item {} 
\sphinxAtStartPar
Pliki konfiguracyjne zwykle znajdują się w katalogu danych, choć zdarza się, że mogą znajdować się w innym katalogu np \sphinxcode{\sphinxupquote{/etc/postgresql/\textless{}wersja\textgreater{}/main}}

\end{itemize}

\end{description}

\item {} \begin{description}
\sphinxlineitem{Katalog logów:}\begin{itemize}
\item {} 
\sphinxAtStartPar
Domyślnie \sphinxcode{\sphinxupquote{/var/log/postgresql}} na Debianie/Ubuntu oraz \sphinxcode{\sphinxupquote{/var/lib/pgsql/\textless{}wersja\textgreater{}/data/pg\_log}} na Red Har/CentOS

\item {} 
\sphinxAtStartPar
zawiera logi PostgreSQL

\end{itemize}

\end{description}

\end{enumerate}


\subsection{Struktura katalogów:}
\label{\detokenize{Konfiguracja-bazy-danych:struktura-katalogow}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{base/}}: Zawiera dane użytkownika dla każdej bazy danych.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{global/}}: Przechowuje dane globalne, np. tabele systemowe.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pg\_xlog/}} lub pg\_wal/ (od wersji 10): Zawiera dzienniki Write\sphinxhyphen{}Ahead Log (WAL).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pg\_clog/}} lub pg\_xact/: Przechowuje dane dotyczące transakcji.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pg\_tblspc/}}: Linki symboliczne do tabel przestrzeni.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pg\_multixact/}}: Dane dotyczące wielokrotnych transakcji.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pg\_subtrans/}}: Dane dotyczące podrzędnych transakcji.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pg\_stat/}}: Dane statystyczne.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pg\_snapshots/}}: Przechowuje dane dotyczące snapshotów.

\end{itemize}


\section{Tabele \sphinxhyphen{} rozmiar, planowanie i monitorowanie}
\label{\detokenize{Konfiguracja-bazy-danych:tabele-rozmiar-planowanie-i-monitorowanie}}

\subsection{Rozmiar}
\label{\detokenize{Konfiguracja-bazy-danych:rozmiar}}
\sphinxAtStartPar
Rozmiar tabel jest kluczowym aspektem zarządzania bazą danych, ponieważ bezpośrednio wpływa na wydajność systemu. Duże tabele mogą prowadzić do dłuższych czasów odpowiedzi na zapytania, zwiększonego zużycia pamięci oraz większych obciążeń wejścia/wyjścia.

\sphinxAtStartPar
\sphinxstylestrong{Monitorowanie rozmiaru tabel}
PostgreSQL dostarcza kilka narzędzi i zapytań SQL, które umożliwiają monitorowanie rozmiaru tabel:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Rozmiar pojedynczej tabeli:}

\end{itemize}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{%
\PYG{k}{SELECT}\PYG{+w}{ }\PYG{n}{pg\PYGZus{}size\PYGZus{}pretty}\PYG{p}{(}\PYG{n}{pg\PYGZus{}total\PYGZus{}relation\PYGZus{}size}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}nazwa\PYGZus{}tabeli\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{AS}\PYG{+w}{ }\PYG{k}{size}\PYG{p}{;}%
}}

\sphinxAtStartPar
To zapytanie zwraca przyjazny dla użytkownika rozmiar całej tabeli, wliczając w to dane, indeksy oraz wszelkie towarzyszące pliki.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Rozmiar wszystkich tabel w bazie danych:}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT}\PYG{+w}{ }\PYG{n}{relname}\PYG{+w}{ }\PYG{k}{AS}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZdq{}Table\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{pg\PYGZus{}size\PYGZus{}pretty}\PYG{p}{(}\PYG{n}{pg\PYGZus{}total\PYGZus{}relation\PYGZus{}size}\PYG{p}{(}\PYG{n}{relid}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{AS}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZdq{}Size\PYGZdq{}}
\PYG{k}{FROM}\PYG{+w}{ }\PYG{n}{pg\PYGZus{}catalog}\PYG{p}{.}\PYG{n}{pg\PYGZus{}statio\PYGZus{}user\PYGZus{}tables}
\PYG{k}{ORDER}\PYG{+w}{ }\PYG{k}{BY}\PYG{+w}{ }\PYG{n}{pg\PYGZus{}total\PYGZus{}relation\PYGZus{}size}\PYG{p}{(}\PYG{n}{relid}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{DESC}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
To zapytanie zwraca listę wszystkich tabel w bazie danych wraz z ich rozmiarami, posortowaną według rozmiaru.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Rozmiar indeksów tabeli:}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT}\PYG{+w}{ }\PYG{n}{indexrelname}\PYG{+w}{ }\PYG{k}{AS}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZdq{}Index\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{pg\PYGZus{}size\PYGZus{}pretty}\PYG{p}{(}\PYG{n}{pg\PYGZus{}relation\PYGZus{}size}\PYG{p}{(}\PYG{n}{indexrelid}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{AS}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZdq{}Size\PYGZdq{}}
\PYG{k}{FROM}\PYG{+w}{ }\PYG{n}{pg\PYGZus{}stat\PYGZus{}user\PYGZus{}indexes}
\PYG{k}{WHERE}\PYG{+w}{ }\PYG{n}{relname}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}nazwa\PYGZus{}tabeli\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
To zapytanie zwraca listę indeksów dla określonej tabeli wraz z ich rozmiarami.


\subsection{Planowanie}
\label{\detokenize{Konfiguracja-bazy-danych:planowanie}}
\sphinxAtStartPar
Planowanie tabel w PostgreSQL obejmuje kilka kluczowych aspektów, takich jak normalizacja, denormalizacja, indeksowanie oraz partycjonowanie.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Normalizacja} \sphinxhyphen{} Normalizacja to proces organizowania danych w bazie danych w taki sposób, aby zminimalizować redundancję i zapewnić integralność danych. Składa się z kilku form normalnych (NF), z których każda eliminuje różne rodzaje redundancji:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Pierwsza forma normalna (1NF)}: Każda komórka tabeli zawiera pojedynczą wartość, a każde pole jest atomowe.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Druga forma normalna (2NF)}: Spełnia wymagania 1NF i zapewnia, że wszystkie kolumny niekluczowe są w pełni zależne od klucza głównego.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Trzecia forma normalna (3NF)}: Spełnia wymagania 2NF i zapewnia, że nie ma zależności przejściowych między kolumnami niekluczowymi.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Denormalizacja} \sphinxhyphen{} Denormalizacja to proces łączenia tabel, aby poprawić wydajność zapytań kosztem zwiększenia redundancji danych. Stosuje się ją wtedy, gdy zapytania często wymagają złączeń wielu tabel, co może wpływać na wydajność.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Indeksowanie} \sphinxhyphen{} Indeksy są kluczowe dla optymalizacji wydajności zapytań. Pozwalają one na szybsze wyszukiwanie, sortowanie i filtrowanie danych. W PostgreSQL dostępnych jest kilka typów indeksów:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{B\sphinxhyphen{}tree}: Najczęściej używany typ indeksu, odpowiedni dla większości operacji wyszukiwania.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Hash}: Szybszy dla operacji równościowych, ale mniej wszechstronny niż B\sphinxhyphen{}tree.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{GIN (Generalized Inverted Index)}: Używany do indeksowania danych wielowartościowych, takich jak tabele JSONB i dokumenty pełnotekstowe.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{GiST (Generalized Search Tree)}: Używany dla bardziej złożonych typów danych, takich jak geometria.

\end{itemize}

\end{enumerate}

\sphinxAtStartPar
Przykład tworzenia indeksu B\sphinxhyphen{}tree:

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{%
\PYG{k}{CREATE}\PYG{+w}{ }\PYG{k}{INDEX}\PYG{+w}{ }\PYG{n}{idx\PYGZus{}nazwa\PYGZus{}kolumny}\PYG{+w}{ }\PYG{k}{ON}\PYG{+w}{ }\PYG{n}{nazwa\PYGZus{}tabeli}\PYG{p}{(}\PYG{n}{nazwa\PYGZus{}kolumny}\PYG{p}{)}\PYG{p}{;}%
}}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\setcounter{enumi}{3}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Partycjonowanie} \sphinxhyphen{} Partycjonowanie polega na podzieleniu tabeli na mniejsze, bardziej zarządzalne części zwane partycjami. Może to znacznie poprawić wydajność zapytań, szczególnie w przypadku dużych tabel. PostgreSQL obsługuje kilka typów partycjonowania:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Partycjonowanie zakresowe (Range Partitioning)}: Dzieli dane na zakresy wartości.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Partycjonowanie listy (List Partitioning)}: Dzieli dane na podstawie wartości z określonej listy.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Partycjonowanie haszowe (Hash Partitioning)}: Dzieli dane na podstawie wartości haszowej.

\end{itemize}

\end{enumerate}

\sphinxAtStartPar
Przykład tworzenia partycji zakresowej:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{CREATE}\PYG{+w}{ }\PYG{k}{TABLE}\PYG{+w}{ }\PYG{n}{orders}\PYG{+w}{ }\PYG{p}{(}
\PYG{n}{order\PYGZus{}id}\PYG{+w}{ }\PYG{n+nb}{serial}\PYG{+w}{ }\PYG{k}{PRIMARY}\PYG{+w}{ }\PYG{k}{KEY}\PYG{p}{,}
\PYG{n}{order\PYGZus{}date}\PYG{+w}{ }\PYG{n+nb}{date}\PYG{+w}{ }\PYG{k}{NOT}\PYG{+w}{ }\PYG{k}{NULL}\PYG{p}{,}
\PYG{n}{customer\PYGZus{}id}\PYG{+w}{ }\PYG{n+nb}{int}\PYG{+w}{ }\PYG{k}{NOT}\PYG{+w}{ }\PYG{k}{NULL}\PYG{p}{,}
\PYG{n}{amount}\PYG{+w}{ }\PYG{n+nb}{numeric}
\PYG{p}{)}\PYG{+w}{ }\PYG{n}{PARTITION}\PYG{+w}{ }\PYG{k}{BY}\PYG{+w}{ }\PYG{n}{RANGE}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{order\PYGZus{}date}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{CREATE}\PYG{+w}{ }\PYG{k}{TABLE}\PYG{+w}{ }\PYG{n}{orders\PYGZus{}2022}\PYG{+w}{ }\PYG{n}{PARTITION}\PYG{+w}{ }\PYG{k}{OF}\PYG{+w}{ }\PYG{n}{orders}
\PYG{k}{FOR}\PYG{+w}{ }\PYG{k}{VALUES}\PYG{+w}{ }\PYG{k}{FROM}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}2022\PYGZhy{}01\PYGZhy{}01\PYGZsq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{TO}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}2023\PYGZhy{}01\PYGZhy{}01\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{CREATE}\PYG{+w}{ }\PYG{k}{TABLE}\PYG{+w}{ }\PYG{n}{orders\PYGZus{}2023}\PYG{+w}{ }\PYG{n}{PARTITION}\PYG{+w}{ }\PYG{k}{OF}\PYG{+w}{ }\PYG{n}{orders}
\PYG{k}{FOR}\PYG{+w}{ }\PYG{k}{VALUES}\PYG{+w}{ }\PYG{k}{FROM}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}2023\PYGZhy{}01\PYGZhy{}01\PYGZsq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{TO}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}2024\PYGZhy{}01\PYGZhy{}01\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Monitorowanie}
\label{\detokenize{Konfiguracja-bazy-danych:monitorowanie}}
\sphinxAtStartPar
Dodatkowo możlive jest monitorowanie wydajności tabel za pomocą:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{pg\_stat\_user\_table:}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT}\PYG{+w}{ }\PYG{n}{relname}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{seq\PYGZus{}scan}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{seq\PYGZus{}tup\PYGZus{}read}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{idx\PYGZus{}scan}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{idx\PYGZus{}tup\PYGZus{}fetch}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{n\PYGZus{}tup\PYGZus{}ins}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{n\PYGZus{}tup\PYGZus{}upd}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{n\PYGZus{}tup\PYGZus{}del}
\PYG{k}{FROM}\PYG{+w}{ }\PYG{n}{pg\PYGZus{}stat\PYGZus{}user\PYGZus{}tables}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{pg\_stat\_activity:}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT}\PYG{+w}{ }\PYG{n}{pid}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{usename}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{datname}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{state}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{query\PYGZus{}start}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{query}
\PYG{k}{FROM}\PYG{+w}{ }\PYG{n}{pg\PYGZus{}stat\PYGZus{}activity}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Podstawowe parametry konfiguracyjne}
\label{\detokenize{Konfiguracja-bazy-danych:podstawowe-parametry-konfiguracyjne}}

\subsection{Plik postgresql.conf}
\label{\detokenize{Konfiguracja-bazy-danych:plik-postgresql-conf}}
\sphinxAtStartPar
Plik \sphinxstyleemphasis{postgresql.conf} zawiera ustawienia dotyczące wydajności, logowania, sieci i wielu innych aspektów.

\sphinxAtStartPar
\sphinxstylestrong{Kluczowe ustawienia:}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Słuchanie połączeń:}

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{listen\PYGZus{}addresses} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{localhost}\PYG{l+s+s1}{\PYGZsq{}}  \PYG{c+c1}{\PYGZsh{} Adresy IP, na których PostgreSQL będzie nasłuchiwać połączeń}
\PYG{n}{port} \PYG{o}{=} \PYG{l+m+mi}{5432}                     \PYG{c+c1}{\PYGZsh{} Port, na którym PostgreSQL będzie nasłuchiwać połączeń}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Pamięć i wydajność:}

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{shared\PYGZus{}buffers} \PYG{o}{=} \PYG{l+m+mi}{128}\PYG{n}{MB}           \PYG{c+c1}{\PYGZsh{} Ilość pamięci RAM przeznaczona na buforowanie danych}
\PYG{n}{work\PYGZus{}mem} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{n}{MB}                   \PYG{c+c1}{\PYGZsh{} Ilość pamięci RAM na operacje sortowania i agregacji na użytkownika}
\PYG{n}{maintenance\PYGZus{}work\PYGZus{}mem} \PYG{o}{=} \PYG{l+m+mi}{64}\PYG{n}{MB}      \PYG{c+c1}{\PYGZsh{} Ilość pamięci RAM na operacje utrzymaniowe (np. VACUUM, CREATE INDEX)}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\setcounter{enumi}{2}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Autovacuum:}

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{autovacuum} \PYG{o}{=} \PYG{n}{on}                  \PYG{c+c1}{\PYGZsh{} Automatyczne czyszczenie i analiza tabel}
\PYG{n}{autovacuum\PYGZus{}naptime} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{n+nb}{min}        \PYG{c+c1}{\PYGZsh{} Częstotliwość uruchamiania procesu autovacuum}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{Plik pg\_hba.conf}
\label{\detokenize{Konfiguracja-bazy-danych:plik-pg-hba-conf}}
\sphinxAtStartPar
Plik \sphinxstylestrong{pg\_hba.conf} odpowiada za kontrolę dostępu do bazy danych PostgreSQL.

\sphinxAtStartPar
\sphinxstylestrong{Przykład konfiguracji:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} TYPE  DATABASE        USER            ADDRESS                 METHOD}

\PYG{c+c1}{\PYGZsh{} Zezwól lokalnym użytkownikom na połączenie}
\PYG{n}{local}   \PYG{n+nb}{all}             \PYG{n+nb}{all}                                     \PYG{n}{md5}

\PYG{c+c1}{\PYGZsh{} Zezwól zdalnym użytkownikom z sieci 192.168.1.0/24 na połączenie}
\PYG{n}{host}    \PYG{n+nb}{all}             \PYG{n+nb}{all}             \PYG{l+m+mf}{192.168}\PYG{l+m+mf}{.1}\PYG{l+m+mf}{.0}\PYG{o}{/}\PYG{l+m+mi}{24}          \PYG{n}{md5}
\end{sphinxVerbatim}


\subsection{Plik pg\_ident.conf}
\label{\detokenize{Konfiguracja-bazy-danych:plik-pg-ident-conf}}
\sphinxAtStartPar
Plik \sphinxstylestrong{pg\_ident.conf} pozwala mapować systemowych użytkowników do użytkowników PostgreSQL.

\sphinxAtStartPar
\sphinxstylestrong{Przykład konfiguracji:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} MAPNAME       SYSTEM\PYGZhy{}USERNAME         PG\PYGZhy{}USERNAME}

\PYG{n}{mymap}           \PYG{n}{johndoe}                 \PYG{n}{john}
\PYG{n}{mymap}           \PYG{n}{janedoe}                 \PYG{n}{jane}
\end{sphinxVerbatim}

\sphinxAtStartPar
W pliku \sphinxstylestrong{pg\_hba.conf} można użyć tej mapy:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{host}    \PYG{n+nb}{all}             \PYG{n+nb}{all}             \PYG{l+m+mf}{127.0}\PYG{l+m+mf}{.0}\PYG{l+m+mf}{.1}\PYG{o}{/}\PYG{l+m+mi}{32}            \PYG{n}{ident} \PYG{n+nb}{map}\PYG{o}{=}\PYG{n}{mymap}
\end{sphinxVerbatim}


\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{search}

\end{itemize}



\renewcommand{\indexname}{Indeks}
\printindex
\end{document}